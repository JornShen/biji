innodb的锁介绍下？

表锁：锁住整张表。innodb 和 MYISAM 都支持表锁。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

行级锁：MYISAM引擎只支持表级锁，而INNODB引擎能够支持行级锁。行级锁有**共享锁（S LOCK）和独占锁**（X LOCK）两种。

LOCK IN SHARE MODE;

共享锁（读写锁）允许事物读一行记录，不允许任何线程对该行记录进行修改。排他锁允许当前事物删除或更新一行记录，其他线程不能操作该记录。

FOR UPDATE;

排他锁:MySQL会对查询结果集中每行都添加排他锁，在事务操作中，任何对记录的更新与删除操作会自动加上排他锁。

页级锁：锁定粒度介于行级锁和表级锁中间的一种锁。一次锁定相邻的一组记录。

innodb的默认事务隔离级别是？ 重复读

innodb下repeatable read能不能避免幻读问题呢？不能

mvcc听过吗？

MySQL的这种机制称为MVCC（多版本并发控制），就是说数据库在事务并发的过程中对数据维护多个版本，使得不同的事务对不同的数据版本进行读写。


行級鎖是鎖一行嗎？還是

為啥要用b+樹做數據庫索引？

b+樹的結構介紹下？

聯合索引要滿足什麼規則？最左匹配规则

为什么要满足这个规则？ 索引是用树的结构来存的。

1. 数据库事务四种特性： （ACID）

原子性：指事务包含的所有操作**要么全部成功，要么全部失败回滚**。原子的。

一致性：事务必须使数据库从一个一致性(统一的)状态变换到另一个一致性状态，也就是说**一个事务执行之前和执行之后都必须处于一致性状态**。（执行结果一致的），没有中间过度态。

隔离性：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，**不能被其他事务的操作所干扰，多个并发事务之间要相互隔离**。
（不被干扰）

持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。

2. 四种隔离级别

1. 未提交读（产生问题：脏读）

事务中的修改，即使没有提交，也对其他事务可见的。导致脏读。

2. 读提交 不可重复读

一个事务从开始到提交之前，所做的操作其他事务是看不见的。但是可能产生，两次同样的查询，可能会得到不同的结果。

使用锁：

行级共享锁（当读到时才加锁），一旦读完该行 ， 立即释放该行级共享锁。一使用完就释放，导致对其他的事务可以修改。

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

3. 可重复读 （解决了不可重复读的问题）

保证多次读取的结果是一样的。但是会产生幻读的情况。

锁：

事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放。(差别在这个地方)

事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

4. 序列化

解决了幻读的情况。

使用锁: 表锁。

幻读的情况：：幻读 : 是指当事务不是独立执行（并发执行情况下）时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。

应为读提交是行级锁，对于新创建的行没有控制的效力。
