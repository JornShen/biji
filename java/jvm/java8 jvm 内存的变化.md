### 堆的划分 (相对于垃圾收集器)

Eden区 —— 新对象或者生命周期很短的对象会存储在这个区域中，这个区的大小可以通过-XX:NewSize和-XX:MaxNewSize参数来调整。新生代GC（垃圾回收器）会清理这一区域。

Survivor区 —— 那些历经了Eden区的垃圾回收仍能存活下来的依旧存在引用的对象会待在这个区域。这个区的大小可以由JVM参数-XX:SurvivorRatio来进行调节。

Eden:Survivor = 8:1:1;

老年代 —— 那些在历经了Eden区和Survivor区的多次GC后仍然存活下来的对象（当然了，是拜那些挥之不去的引用所赐）会存储在这个区里。这个区会由一个特殊的垃圾回收器来负责。年老代中的对象的回收是由老年代的GC（major GC）来进行的。

对象来源：

1. 新对象过大，会直接分配在老年代中.

2. 如果在 Minor GC 的时候, 复制过程中当To幸存区被填满了，剩余的对象会被复制到老年代中。

3. 复制的过程中, 针对 From 幸存区(survivor)中的幸存对象(上一次垃圾收集下来的对象)，会考虑对象年龄,如果年龄没达到阀值(tenuring threshold)，对象会被复制到To 幸存区(survivor)。如果达到阀值对象被复制到老年代。


#### 方法区

也被称为非堆区域（在HotSpot JVM的实现当中）
它被分为两个主要的子区域

**持久代** —— 这个区域会存储包括 类定义，结构，字段，方法（数据及代码）以及常量在内的类 相关数据。它可以通过-XX:PermSize及 -XX:MaxPermSize来进行调节。如果它的空间用完了，会导致java.lang.OutOfMemoryError: PermGen space的异常。

**代码缓存** ——这个缓存区域是用来存储编译后的代码。编译后的代码就是本地代码（硬件相关的），它是由JIT（Just In Time)编译器生成的，这个编译器是 Oracle HotSpot JVM 所特有的。

在java8中

**持久代** 已经被 **彻底删除** 了，取代它的是另一个内存区域也被称为 **元空间**。

目的是减少持久代内存溢出.

但类的元数据信息（metadata）还在，只不过 **不再是存储在连续的堆空间** 上，而是移动到叫做“Metaspace”的 **本地内存（Native memory）**, 可以使用虚拟内存中.

类的元数据信息转移到Metaspace的原因是 **PermGen很难调整** 。PermGen中类的元数据信息在每次FullGC的时候可能会被收集，但成绩很难令人满意。而且应该为PermGen分配多大的空间很难确定，因为PermSize的大小依赖于很多因素，比如JVM加载的class的总数，常量池的大小，方法的大小等。

GC不令人满意. 分配空间不确定.

[](http://blog.csdn.net/zhushuai1221/article/details/52122880)

永久代的移除对最终用户意味着什么？

由于类的元数据可以 **在本地内存(native memory)之外分配**,所以其最大可利用空间是整个系统内存的可用空间。这样，你将不再会遇到OOM错误，**溢出的内存会涌入到交换空间**。最终用户可以为类元数据指定最大可利用的本地内存空间，JVM也可以增加本地内存空间来满足类元数据信息的存储.

元空间和永久代的区别:

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中**，而是使用 **本地内存**。因此，默认情况下，元空间的大小 **仅受本地内存限制**，但可以通过以下参数来指定元空间的大小：

为什么要做这个转换？所以，最后给大家总结以下几点原因：

1、字符串存在永久代中，容易出现 **性能问题和内存溢出**。

2、类及方法的信息等比较难确定其大小，因此 **对于永久代的大小指定** 比较困难，太小容易出现 **永久代溢出**，太大则容易导致老年代溢出。

3、永久代会为 GC 带来不必要的复杂度，并且 **回收效率偏低**。

4、Oracle 可能会将 HotSpot 与 JRockit 合二为一。
