#### 项目描述相关整理

关键项目描述：(很重要),要尽量细节，不要被问倒了。

###### 我知盘中餐项目

使用 websocket 设计实现了扫码点餐同步功能。

实现方案：

1. 为什么要使用 websocket ?

websocket 是在Web浏览器和服务器之间进行任意的**双向数据传输**的一种技术。双向通信，无阻塞进行长连接通信。

和其他技术的区别:

如果不用 websocket 话，一般我们使用了 ajax 轮循 (定时向服务器发送 get 请求)，获取数据更新。这种做法，缺点就是 **某段时间数据没有更新，浏览器一直向服务器端发送get请求到还是老的数据，这样浪费网络带宽和cpu的利用率**。但是如果把周期调大 ，无法保证数据的实时性。

另一种解决方案是，long-polling,  服务端对浏览器请求在没有数据的情况下进行阻塞，保持住这个请求，等有新的数据到来的时候，再响应这个请求。如果服务器的数据长期没有更新，一段时间后，这个Get请求就会超时，Browser/UA收到超时消息后，再立即发送一个新的Get请求给服务器。然后依次循环这个过程。这种情况虽然减小了网络带宽和CPU利用率的问题。缺点就是：

Browser显示实时数据最快的时间为2×RTT（往返时间），**实时性有点缓慢**。数据更新只能一个一个请求来。并且由于 http数据包的头部数据量 往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少。**通信数据的浪费**

这个功能使用了tomcat中的 websocket，通过调用了java-websocket  api 进行编写。我主要写了服务端的代码。

代码的架构：

```java
@ServerEndpoint(value = "/multiorderwebsocket",
	       configurator=GetHttpSessionConfigurator.class,
	       decoders = MultiTempDecoder.class,
	       encoders = MultiTempEncoder.class
		)
public class MulUserOrdersocket {

  @OnOpen
  public void onOpen(Session session, EndpointConfig config) {
      // 初始化绑定处理
  }

  /**
    * 收到客户端的连接后调用的方法
    */
   @OnMessage
   public void onMessage(MultiUserOrderTemp temp, Session session) {
		 	// 消息处理函数

   }

   @OnError
   public void onError(Session session, Throwable error) {
		 // 错误处理

   }


   /**
   * 断开连接
   */
  @OnClose
  public void onClose() {
		// 关闭断开连接

  }

```

通过调用javaee的接口来调用，在后台实现 WebSocket 服务端 (Endpoint), 一个websocket对应一个Endpoint服务，同时 Endpoint 是有状态的, **web容器为每个会话创建一个Endpoint对象实例, 维护当前会话状态信息**。

websocket 的长连接与 HTTP 长连接有很大不同。HTTP 长连接只是为了向同一服务器发送请求时复用已有的 TCP 连接, 优化性能, 发送请求带不同的 cookie 就可能关联不同的 HTTP session（一类用来在客户端与服务器之间保持状态的解决方案）。 **一个 websocket 长连接只为一个会话服务, 使用该会话的进行收发消息**。程序都是通过这个websocket 的session进行通信的。

===========================
#### 如何理解session的机制？

服务器端保存客户端状态（存放用户访问的部分数据）的一种解决方案。服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

#### session 的创建过程

当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识- 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个 session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID，

####  session 的删除

由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。

一般情况下，session都是存储在内存里，当服务器进程被停止或者重启的时候，内存里的session也会被清空，如果设置了session的持久化特性，服务器就会把session保存到硬盘上，当服务器进程重新启动或这些信息将能够被再次使用，Weblogic Server支持的持久性方式包括文件、数据库、客户端cookie保存和复制。

1.session的创建时间：

直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建

2. session被销毁的时间：

a.程序调用HttpSession.invalidate();或b.距离上一次收到客户端发送的session id时间间隔超过了session的超时设置;或c.服务器进程被停止（非持久session）

3. 做到在浏览器关闭时删除session:

严格的讲，做不到这一点。可以做一点努力的办法是在所有的客户端页面里使用javascript代码window.oncolose来监视浏览器的关闭动作，然后向服务器发送一个请求来删除session。但是对于浏览器崩溃或者强行杀死进程这些非常规手段仍然无能为力。(通过客户端进行控制)

4. 开两个浏览器窗口访问应用程序会使用同一个session还是不同的session。对session来说是只认id不认人，因此不同的浏览器，不同的窗口打开方式以及不同的cookie存储方式都会对这个问题的答案有影响。

5. 防止用户打开两个浏览器窗口操作导致的session混乱。可以通过设置客户端的令牌来解决。就是在服务器每次生成一个不同的id返回给客户端，同时保存在session里，**客户端提交表单时必须把这个id也返回服务器，程序首先比较返回的id与保存在session里的值是否一致，如果不一致则说明本次操作已经被提交过了**。

#### session 和 cookie 的区别

（因为http是无状态的，所以为了获得状态，session和cookie是相对的解决方案）

Session是由应用服务器**维持的一个服务器端的存储空间**，用户在**连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID为标识符来存取服务器端的Session存储空间**。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。

Cookie是客户端的存储空间，由浏览器来维持。

session是以cookie或URL重写为基础的，默认使用cookie来实现。

当我们把浏览器的cookie禁止后，web服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到sessionid=KWJHUG6JJM65HS2K6之类的字符串。

session cookie针对某一次会话而言，会话结束sessioncookie也就随着消失了，而persistentcookie只是存在于客户端硬盘上的一段文本（通常是加密的），而且可能会遭到cookie欺骗以及针对cookie的跨站脚本攻击，自然不如session cookie安全了。

通常sessioncookie是不能跨窗口使用的，当你新开了一个浏览器窗口进入相同页面时，系统会赋予你一个新的sessionid，这样我们信息共享的目的就达不到了，此时我们可以**先把sessionid保存在persistentcookie**中，然后在新窗口中读出来，就可以得到上一个窗口SessionID了，这样通过session cookie和persistentcookie的结合我们就实现了**跨窗口的session tracking（会话跟踪）**。

sessioncookies位于服务器端，persistentcookie位于客户端，可是session又是以cookie为基础的，明白的两者之间的联系和区别。

===========================

### 实现方案 （整个业务逻辑的详细的设计过程）

使用 websocket 实现帮我们实现点餐的实时同步数据同步。在实现的过程中，主要编写了websocket的服务端的同步的代码。

首先我自己设计了中间过度数据的字段的设计（比如菜品类型，数量，以及对菜品的操作，是否提交订单等数据）。由于没有给详细的设计文档，整个过程自己独立进行设计实现。

然后设计 服务端和客户端 交互过程

实例的状态设计：每次有一个 websocket 的请求，服务端就会生成一个 websocket 实例，该实例保存相应的状态。该实例会保存了和这个请求连接的通讯的session (这个和 http session 是不一样的，专门用来和客户端进行通信)，保存了用户的信息引用, 以及餐馆的id，餐桌的id，（这两个标识唯一的一个餐桌实例的唯一特征），一个集合引用这个餐桌的所点的菜品的实例。然后，为了实现彼此之间的通信，我把所有的 websocket 实例统一放在内存里面（细问就说静态集合），这样可以根据其他实例 餐馆id，餐桌 id进行通讯，但是为了避免每次都遍历所有的 socket 实例判断，我在每个 websocket 实例里面另外开了一个通信集合，在初始化连接的过程中，遍历一次所有的websocket实例，然后将其他同一桌的socket实例保存在这个集合当中，这样就避免每次遍历所有的socket实例。

接下来，在实际的点餐过程中，还需要同步 同一个餐桌 每个人所点的菜品的实例，**使用 sychronized 同步块进行加锁控制同步数据的更新**。在更新菜品的操作这个地方，遇到了问题。没有意识到集合里面存放的是对象的应用，然后就都去对同一餐桌其他人的 菜品的集合 进行相同的操作。这样导致数据的混乱。通过这个问题，深刻的理解了集合存放引用的特性。在一个人的菜品数目进行更新，其他人的菜品实例也会进行更新。如果是添加删除的话，则需要另外对其他人的菜品集合进行更新。

socket 实例的这个菜品的集合因为这个集合存放的是引用，实际上，每一道菜仅仅在内存上创建一个实例。在新加入的点餐成员中，要将同一座其他的人的引用加入到自己的通信集合，也可以很快从其他点餐人那里获得引用就可以快速实现数据的同步。将这个实例添加进其他的通信集合里面。

当用户退出的时候，也将自己从其他人的通信实例集合中删除。

总结：tomcat websocket 以及 java.websocket-api 接口，以及框架 帮我们解决了 websocket 实例，以及 客户端和服务端之间的通信问题。在此基础上， 解决同一个餐桌 socket 实例之间的通信问题，点的菜品更新问题， 以及 点餐人员加入，订单提交的问题。

功能涉及到的问题？

1. 同一个餐桌实例同步通信问题。加入和退出问题。

2. 菜品操作问题。订单提交问题。

3. 传输数据编码和解码问题。

##### 提高 websocket 的连接数目问题

服务器的参数调优: 一般会修改两个文件，/etc/sysctl.conf和/etc/security/limits.conf， 用来配置TCP/IP参数和最大文件描述符。(更改系统参数来提高 tcp/ip 的连接数, 最大的文件描述符数)

应用运行时内存调优:Java 应用内存调优, 服务器使用12G内存，吞吐率优先的垃圾回收器：

[参考](http://blog.jobbole.com/103995/)

##### websocket 的负载实现

一个单独的服务可以处理**65536个套接字连接因为这是TCP可用端口的最大数量**。由于WS连接自带TCP而且每个WS客户端占据一个端口我们可以明确的说websocket 连接的数量也是有限制的。 对于每个IP地址服务器可以处理65,536个套接字。 因此，通过向服务器 **添加额外的网络接口** 可以轻松扩展数量。 最好限制应用程序代码中每个节点的WS连接。

另一种解决方案：

![](pic/a2.jpg)

---

##### 项目中遇到的问题？

项目的技术版本问题, 包括 javaee 包, tomcat 版本的问题兼容问题。在更改版本的过程中就出现兼容性问题。 顺着日志查找问题。进入源码查看问题，最后找到源码冲突的地方。

##### 相关联的其他的可能会问到的问题:

struct  和 springmvc 的区别？

答：首先两者都是 mvc框架， 处理http请求，

1. **Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文**.
struct2 不容易实现 restful, Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。


2. SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，**方法之间不共享变量**，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其**所有Action变量是共享的**，这不会影响程序运行，却给我们编码 读程序时带来麻烦，**每次来了请求就创建一个Action，一个Action对象对应一个request上下文**。

3. 由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成**一个一个Map**，供给每个Action使用，并保证线程安全，所以在原则上，**是比较耗费内存的**。

4. 拦截器实现机制上，Struts2有以自己的**interceptor机制**，SpringMVC用的是**独立的AOP方式**，这样导致Struts2的**配置文件量**还是比SpringMVC大。

5. **SpringMVC的入口是servlet，而Struts2是filter**.

6. **SpringMVC集成了Ajax，使用非常方便**，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。

7. Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。

8. SpringMVC开发效率和性能高于Struts2。

9. SpringMVC可以认为已经100%零配置。

---

hibernet 和 mybatis 的对比:

1. Hibernate 对JDBC提供了较为完整的封装。**Hibernate的O/R Mapping实现了 POJO 和数据库表之间的映射，以及SQL的自动生成和执行**。Mybatis主要着力点**在于 POJO 与 SQL 之间的映射关系**。然后通过映射配置文件，将SQL所需的参数，以及返回的结果字段映射到指定 POJO 。

2. Mybatis由于所有SQL都是依赖数据库书写的，所以扩展性，迁移性比较差。Hibernate与数据库具体的关联都在XML中，所以HQL对具体是用什么数据库并不是很关心。

3. 缓存机制对比:

相同点：二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案。

不同点：Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。

4. 优势的对比：

Hibernate优势

Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。

Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。

Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。
Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。

Mybatis优势

MyBatis可以进行更为细致的SQL优化，可以减少查询字段。

MyBatis容易掌握，而Hibernate门槛较高。

总结：

Mybatis：小巧、方便、高效、简单、直接、半自动化

Hibernate：强大、方便、高效、复杂、间接、全自动化

#### 广西移动卫星项目

生成对账文件（这个文件主要是用来计费对账，平台这边的账单要和电信集团那边进行对账）上传：

业务要求：每天定时从本地数据库读取数据，按照设计文档规定的字段要求，生成相应的文件，用ftp传送到指定的服务器地址上。定时传送采用了 quartz 来实现。

主要在 execute() 方法里面编写业务，跟着设计文档走，思路比较清晰，字段比较多，根据不同卫星编号，开多线程处理，生成对账文件。

详细的实现方法：

一个卫星编号，开一个线程，统计当天的充值记录，按要求生成文件。一些复杂的字段操作。在实现的过程中，遇到了一个小小的多线程的常见的临界区问题。一开始，我是将所有生成的文件, 都同一放到同一目录下，然后创建完毕后，统一一起上传文件，这样比较方便，避免生成一个文件上传一次文件，当然这样就不会线程安全性问题。在具体的上传操作时候，就会遍历这个文件夹下的文件，上传文件将其改名挪到备份文件夹下面。因为开多个线程，对这文件夹临界区又没有进行互斥，结果出现了异常。要纠正这个错误，可以多种方案。一种是对于不同卫星编号，在目录下在创建子目录，以这个卫星编号为命名。这样就可以将不同线程读取的目录不同。另一种是，可以等所有线程都创建完文件后在统一进行上传。 也就是说在 execute() 方法开多个线程执行完之后，在下面等所有线程执行完完毕之后，统一进行文件的上传。可以使用 CountDownLatch 和 CyclicBarrier 工具类进行控制执行。

可能会问到的问题：

1. jdbc PreparedStatement 的常见问题

PreparedStatement 用于执行参数化查询, 防止sql注入，数据库系统会**对sql语句进行预编译处理**（如果JDBC驱动支持的话），预处理语句将被预先编译好，这条预编译的sql查询语句能在将来的**查询中重用**，这样一来，它比Statement对象生成的查询速度更快 (数据库对SQL语句的分析，编译，优化已经在第一次查询前完成了), 同时防止 sql注入, 在参数化查询的情况下，不会将参数视为sql的一部分来执行，而是在数据库完成sql编译后，才套用参数运行，因此就算参数中含有破坏性的指令，也不会被数据库所运行。

避免SQL注入的第二种方式：

在组合SQL字符串的时候，先对所传入的参数做字符取代（将单引号字符取代为连续2个单引号字符，因为连续2个单引号字符在SQL数据库中会视为字符中的一个单引号字符。

2. java 多线程是如何实现的

操作系统维护了一个任务队列，Java调用.start()之后会把任务放进队列之中等待执行
CPU不会一直执行同一个任务，而是每执行一段时间，就保存当前任务的状态，然后从队列中取到下一个任务继续执行。

3. 线程池的实现原理

工作线程 和 阻塞队列
见 java并发编程的艺术。

4. quartz 定时器的实现原理  --> 见quartz.md

#### 流量经营平台

###### 平台业务（经常被问到）

常见用途：某些企业为了奖励用户积分，向运营商购买流量。进行营销。

流量经营，顾名思义，电信针不同客户销售销售的一个运营平台，为了提高流量的销售。这种运营其实比较常见，比如饿了么有流量饿卡等， 以及其他应用作为营销的奖励。都需要购买这种类型的流量。这个平台就是类似于这种销售。

参与角色：福建省电信省内运维人员、客户经理、政企客户、合作伙伴、平台角色、终端用户

网页版有运营管理员卖流量，其他企业用户买流量，大企业买流量，分配给用户，分销给小企业。小企业分配给指定的用户。最后都是分销给用户。手机端，我导师做的，用户可以自己买流量，领取流量等。主要业务是这一块，当然里面有各种合同管理，合同审核的功能。
这个只能简单讲一下，整个需求文档 word 132页，需求比较多。

#### 使用到的技术

主流的ssm后台框架,  分布式服务框架 dubbo, 数据库方面用到了 redis 集群, (mongdb 集群), mysql, mycat 中间件, 前端使用自研的 fish 框架, 其他的技术主要有 quartz 定时器，定时跑任务, 还有开源的工作流引擎 Activity.

#### 典型的实现功能, 实现过程

做的东西不止这些。开发过程，全栈编写代码。

短信验证功能：

用户输入手机号码 --> 传入后台验证是否存在该号码对应的用户 --> 用户输入正确号码后，生成验证码, 六位 --> 存放入 redis 里面，redis 的string 类型进行存放，设置过期时间, 60s (expire) --> 用户输入号码，将验证码和电话号码传到后台，和 redis 中存放的数据号码进行比较，如果失败，返回验证码错误，如果成功，根据电话号码，从数据库里面取出用户的信息，先判断用户是否已经审核通过，用户是否账号已经被锁定，当都满足条件的时候，将用户的信息放在session里面，以及将用户的信息传送到前端。最后返回。

合同监控功能：

从三四张表格里面统计出要去的数据，然后在前端分页进行显示，还增加了查询功能，在这个部分的时候，还是看到了它内部的设置的mybatis 分页拦截器。是拦截StatementHandler的 prepare 方法，mybitis 内部采用了动态代理实现责任链模式，在intercept方法里面进行拦截，主要原理是正则匹配方法名称，看是否需要拦截，如果是的话，就取出sql语句，进行改写来实现的。

更改审批流程，这里就涉及到 Activity的工作流引擎

#### 遇到的问题

###### 短息验证

1. 遇到问题是 短信验证 需要连续登录两次才能登录进去的问题。

前端采用 ajax 判断 session 是否过期，ajaxSetup() 方法为全局的 AJAX 请求设置默认值，设置ajax的全局设置。每次请求都会判断 session 是否超时。服务端有设有session的拦截器，拦截所有请求，判断是否有。这个过滤器会首先判断session里面是否有用户信息，如果有的话，会进行权限的判断， 没有权限会进行重定向跳转页面。如果发现session里面没有用户信息，就是登录信息没有或者过期了，这个时候会在判断URL是不是配置文件里面放行的URL。如果是就放行。如果不是的话， 就在返回的header里面加入, sessionstatus 的key 和 timeout 的value。客户端就会去判断这个 header 里面的 sessionstatus 的key，如果是timeout的话，就清空cookie，跳转首页，要去用户重新登录。那么为什么会进行需要两次登录呢？ 因为我没有放行短信登录请求的url（在配置文件里面加入放行的url），导致用户第一次登录的时候，请求先被过滤器过滤，这个时候没有在session里面放入用户信息，当请求过滤后，处理后，在session里面放入用户信息了。但是客户端读取到过滤器的sessionstatus的设置，它就当做没有登录处理。当第二次登录的时候，由于之前有用户信息放入 session 了，就当做已经登录来处理。用户就可以登录。所以最终就是在一个配置文件里面填写相应的放行URL。这个bug还是调试了很久的。最后弄懂了整个原理。(知道了判断session超时的一种方法。)

#### 扩展问题

1. filer 过滤器 和 interceptor 拦截器的区别
过滤器是在 web.xml 文件中配置，interceptor 是在springmvc 中进行配置，过滤器过滤的范围比较大，除了过滤请求，还可以过滤一些资源，拦截器一般过滤请求。过滤器依赖sevlet 容器，拦截器依赖spring框架。实现方面，过滤器主要基于函数回调，拦截器主要基于java反射机制。过滤器在拦截器之前先处理。

2. session 和 cookie 的区别， session 的过期时间设置
见上文

方法:

1. 在 web.xml 中设置时间，当客户端20分钟内都没有发起请求时，容器会将session干掉。时间计算，最后一次请求时间与当前时间的相隔，超过指定时间就算是超时了。

2. 在代码里面设置



3. ajax 的底层原理





4. session
