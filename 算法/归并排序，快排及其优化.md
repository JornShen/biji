#####  归并排序
如果有两个数组已经有序，那么可以把这两个数组归并为更大的一个有序数组。

归并排序便是建立在这一基础上。要将一个数组排序，可以将它划分为两个子数组分别排序，然后将结果归并，使得整体有序。子数组的排序同样采用这样的方法排序，这个过程是递归的。

1. 小数组可以使用插入排序或者选择排序，避免递归调用。

2. 在 merge() 调用之前，可以判断一下 a[mid] 是否小于等于 a[mid+1] 。如果是的话那么就不用归并了，数组已经是有序的。

3. 节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。

4. 在 merge() 方法中的归并过程需要判断 i 和 j 是否已经越界，即某半边已经用尽。可以用另一种方式，去掉检测是否某半边已经用尽的代码。具体步骤是将数组 a[] 的后半部分以降序的方式复制到 aux[] ，然后从两端归并。对于数组 {1,2,3} 和 {2,3,5} ,第一个子数组照常复制，第二个则从后往前复制，最终 aux[] 中的元素为 {1,2,3,5,3,2} 。这种方法的缺点是使得归并排序变为 不稳定 排序。

快排

快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。

优化：

1. 当待排序序列的长度分割到一定大小后，使用插入排序

原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排

2. 在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。

3. 优化递归操作

快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化

4. 使用并行或多线程处理子序列.
